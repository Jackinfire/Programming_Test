Classes	and Inheritance	: Inheritance can be used to avoid repeating code in similar classes by putting the data and functionality that are common to those classes into a single superclass, and then the more specific classes can inherit that data and functionality. In this case, the data and functionality common to Drone, Keeper and Lion are: data:Name, position, GPSid, functionality:getting the GPS position from the id, and drawing on the map. There is inheritance in the shapes. 4/10
Encapsulation : Good use of private fields and getters 10/10
Polymorphism : None used. Polymorphism can be used to draw all of the map objects, without having to know which specific object they are, by using subtype polymorphism. If Keeper, Lion, Drone inherit from a superclass, their object references can be added to an ArrayList of that superclass. If the superclass has an abstract method 'draw' which is overriden in the subclasses, then calling 'draw' on the superclass will call the specific 'draw' in the subclass. A loop can then iterate through the ArrayList calling 'draw' on each element, without having to know if they are Drone, Keeper or Lion. 0/10
Exceptions and Error handling : Not handled - if it can't contact the location system, the program will crash by throwing a top level exception. Exceptions should be handled gracefully - possibly with a message to the user. 5/10
Organization : Good use of packages 10/10
Attempt : If f.setVisible() is moved until after the Park is added, the shapes are drawn, but not the labels. It doesn't loop to update the positions with time 7/10
Flexibility for Future : ArrayLists of objects are not used, and the members of the Park are hard-coded as specific variables, so it would be more difficult to add new Keepers, Lions, drones etc 0/10
Alerts : Implemented - good! 10/10
